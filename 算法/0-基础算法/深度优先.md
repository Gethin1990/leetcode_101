# 深度优先

```py
# %% build Tree
class TreeNode:
    def __init__(self, val=0, left=None, right=None) -> None:
        self.val = val
        self.left = left
        self.right = right
class Tree:
    def __init__(self) -> None:
        self.root = None

    def add(self, item):
        node = TreeNode(item)

        if self.root is None:
            self.root = node
        else:
            q = [self.root]
            while q:
                point = q.pop(0)
                if point.left is None:
                    point.left = node
                    return
                if point.right is None:
                    point.right = node
                    return
                else:
                    q.append(point.left)
                    q.append(point.right)

    def travel(self, root: TreeNode):
        if root is None:
            return []
        arr = []
        q = []
        q.append(root)
        while q:
            point = q.pop(0)
            arr.append(point.val)
            if point.left:
                q.append(point.left)
            if point.right:
                q.append(point.right)
        return arr

# %%
def do(root: TreeNode):
    def dfs(node,depth):
        if node is None:
            return 0  # depth base
        print(depth) # tag depth
        l_o = dfs(node.left,depth+1)
        r_o = dfs(node.right,depth+1)
        deep = max(l_o, r_o)+1
        return deep

    return dfs(root,0)

tree = Tree()
arr = [1,2,3,4,5]
for val in arr:
    tree.add(val)
do(tree.root)
```
