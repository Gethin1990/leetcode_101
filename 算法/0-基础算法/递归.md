# Code

``` py
def do(nums):
    i = 0
    n = len(nums)  # =n，细节1：正常声明
    # 递归函数
    def re_fn(i):
        if(i >= n):  # 细节2：>= 会递归n次
            return "result"
        print("pre i:", i)  # 细节3 递归前置操作 - 递推 fn
        # i+=1 # 细节5 如果动态操作放在pre fn中，则后续需要suf fn来修补。
        o = re_fn(i+1)  # 执行递归 递归逻辑在i+1 左in 右out
        #i-=1
        print("suf i:", i, "suf o:", o)  # 细节4 回归后置操作 i是过程参数会自动回归，而o是输出
        return i  # 细节4 o 有3种可能性 last 值, i 过程值, 和没有返回的None值, 这取决于你的返回
    # 调用递归
    return re_fn(i)
    # re_fn(i)
nums = [6, 5, 4, 3, 2, 1]
r = do(nums)
print(r)
```

``` py
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_list(count: int) -> ListNode:
    i = 0
    sentinel = ListNode(0)
    node = ListNode(0)
    sentinel.next = node
    _current = node
    while _current:
        if i == count:
            break
        i += 1
        _current.next = ListNode(i)
        _current = _current.next

    li = sentinel.next
    return li

def do(node: ListNode):
    def re_fn(node):
        if(node is None or node.next is None):
            return node
        print("pre:", node.val)
        o = re_fn(node.next)
        print("suf:", node.val, "out:", o.val)
        #node.next = o
        return node
    return re_fn(node)
node = build_list(4)
r = do(node)
print(r.val)
```
